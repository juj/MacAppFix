//
//  main.cpp
//  MacAppFix
//
//  Created by LudoCraft User on 3/20/12.
//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.
//

#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <sstream>
#include <algorithm>

using namespace std;

struct Dylib
{
    string baseFilename;
    string fullpath;
    vector<string> dependencies;
};

map<string, Dylib> dylibs;

vector<string> &split(const string &s, char delim, vector<string> &elems) {
    stringstream ss(s);
    string item;
    while(getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

vector<string> split(const string &s, char delim) {
    vector<string> elems;
    return split(s, delim, elems);
}

// trim from start
static inline std::string &ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
}

// trim from end
static inline std::string &rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
}

// trim from both ends
static inline std::string &trim(std::string &s) {
    return ltrim(rtrim(s));
}

string PathBasename(string fullpath)
{
    return split(fullpath, '/').back();
}

bool StartsWith(string str, const char *str2)
{
    return strstr(str.c_str(), str2) == str.c_str();
}

bool EndsWith(string str, const char *str2)
{
    if (str.length() < strlen(str2))
        return false;
    return !strcmp(str.c_str() + str.length() - strlen(str2), str2);
}

/// Returns the path 'ref' relative to 'base'.
string PathRelativeTo(string base, string ref)
{
    vector<string> items1 = split(base, '/');
//    if (items1.size() > 0 && (items1.back().empty || EndsWith(items1.back(), ".dylib")))
//        items1.pop_back();
    
    vector<string> items2 = split(ref, '/');
 //   if (items2.size() > 0 && (items2.back().empty || EndsWith(items2.back(), ".dylib")))
 //       items2.pop_back();
    while(items1.size() > 0 && items2.size() > 0 && items1.front() == items2.front())
    {
        items1.erase(items1.begin());
        items2.erase(items2.begin());
    }
    string relPath;
    for(size_t i = 0; i < items1.size(); ++i)
        relPath += "/..";
    for(size_t i = 0; i < items2.size(); ++i)
        relPath += "/" + items2[i];
    relPath = &relPath[1]; // Remove first '/' generated by above loops.
    return relPath;
}

bool FileExists(const char *file)
{
    FILE *handle = fopen(file, "rb");
    if (!handle)
        return false;
    fclose(handle);
    return true;    
}

string ReadFileToString(const char *file)
{
    FILE *handle = fopen(file, "rb");
    if (!handle)
        throw "Error: Can't open command result file!";
    fseek(handle, 0, SEEK_END);
    long fsize = ftell(handle);
    fseek(handle, 0, SEEK_SET);
    vector<char> v;
    v.resize(fsize);
    if (fsize > 0)
        fread(&v[0], 1, fsize, handle);
    fclose(handle);
    if (fsize == 0)
        throw "Error: command result file size is zero!";
    return string(&v[0], &v.back());

}
string RunCommand(string cmd)
{
    char out[256];
    static int tempCounter = 1;
    sprintf(out, "tempfile_%d.txt", tempCounter++);
//    cout << "Executing '" << (cmd + " > " + out) << "'" << endl;
    system((cmd + " > " + out).c_str());
    string result = ReadFileToString(out);
    system((string("rm ") + out).c_str());
    return result;
}

void CopyFile(const char *file, const char *newLocation)
{
    stringstream ss;
    ss << "cp " << file << " " << newLocation;
    cout << ss.str() << endl;
    system(ss.str().c_str());
}

template<typename T>
void RemoveDuplicates(vector<T> &v)
{
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
}

vector<string> FindAllDylibsAndExes(const char *path)
{
    cout << "Finding all dylibs and exes from " << path << endl;
    string dylibsStr = RunCommand(string("find ") + path + " -name *.dylib");
    vector<string> dylibs = split(dylibsStr, '\n');
    string exesStr = RunCommand(string("find ") + path + " -type f -perm -o+rx");
    vector<string> exes = split(exesStr, '\n');
    dylibs.insert(dylibs.end(), exes.begin(), exes.end());
    RemoveDuplicates(dylibs);
    return dylibs;
}

/// Returns true if the given path points to a .dylib that should not be rewritten.
bool IsSystemDylibLocation(string path)
{
    return StartsWith(path, "/System") || StartsWith(path, "/usr");
}

vector<string> FindDylibDeps(const char *dylibname)
{
    string deps = RunCommand((string("otool -L ") + dylibname).c_str());
    vector<string> depslines = split(deps, '\n');
    for(size_t i = 0; i < depslines.size(); ++i)
    {
        // Parse lines like 
        // '@executable_path/../Components/libOgreRTShaderSystem.dylib (compatibility version 0.0.0, current version 1.8.0)'
        vector<string> l = split(depslines[i], '(');
        if (l.size() == 2)
        {
            depslines[i] = trim(l.front());
            if (IsSystemDylibLocation(depslines[i]))
            {
                // For the purposes of this application, system .dylib dependencies don't even exist, so skip those.
                depslines.erase(depslines.begin()+i);
                --i;
            }
        }
        else
        {
//            cout << "Error: Could not parse dependency '" << depslines[i] << "'!" << endl;
            depslines.erase(depslines.begin()+i);
            --i;
        }
    }
    return depslines;
}

                                                     
int main (int argc, const char * argv[])
{
    if (argc != 2)
    {
        cout << "This tool fixes Mac OSX application bundle .dylib lookups." << std::endl;
        std::cout << "Usage: " << argv[0] << " /path/to/bundled.app" << std::endl;
        return 0;
    }

    // string appPath = "/Users/lc/naali/build/Tundra.app";
    string appPath = argv[1];
    // Collect all dylibs and their dependencies.
    vector<string> ds = FindAllDylibsAndExes(appPath.c_str());
    for(size_t i = 0; i < ds.size(); ++i)
    {
        Dylib d;
        d.fullpath = ds[i];
        d.baseFilename = PathBasename(d.fullpath);
        d.dependencies = FindDylibDeps(d.fullpath.c_str());        
//        cout << ds[i] << " depends on " << endl;
//        for(size_t j = 0; j < d.dependencies.size(); ++j)
//            cout << "   " << d.dependencies[j] << endl;
            
        dylibs[d.baseFilename] = d;        
    }
    
    // Do another pass through all the dylibs, and find all .dylib files we need to deploy.
    for(map<string, Dylib>::iterator iter = dylibs.begin(); iter != dylibs.end(); ++iter)
    {
        Dylib &d = iter->second;
        
        for(size_t j = 0; j < d.dependencies.size(); ++j)
        {
            string dependee = PathBasename(d.dependencies[j]);
            if (dylibs[dependee].fullpath.empty()) // this .dylib cannot be found from the application bundle?
            {
                if (EndsWith(dependee, ".dylib")) // Only automatically deploy single individual .dylibs.
                {
                    if (FileExists(d.dependencies[j].c_str()))
                    {
                        cout << "Deploying missing .dylib from " << d.dependencies[j] << " to " << (appPath + "/Contents/Components") << endl;
                        CopyFile(d.dependencies[j].c_str(), (appPath + "/Contents/Components").c_str());
                    }
                }
            }
        }
    }
    
    // Now re-do the search so that we pick up all the dylibs we copied.
    dylibs.clear();
    ds = FindAllDylibsAndExes(appPath.c_str());
    for(size_t i = 0; i < ds.size(); ++i)
    {
        Dylib d;
        d.fullpath = ds[i];
        d.baseFilename = PathBasename(d.fullpath);
        d.dependencies = FindDylibDeps(d.fullpath.c_str());        
//        cout << ds[i] << " depends on " << endl;
 //       for(size_t j = 0; j < d.dependencies.size(); ++j)
  //          cout << "   " << d.dependencies[j] << endl;
        
        dylibs[d.baseFilename] = d;        
    }
    
    // Now we have knowledge of all the dylibs. Fix up references.
    for(map<string, Dylib>::iterator iter = dylibs.begin(); iter != dylibs.end(); ++iter)
    {
        Dylib &d = iter->second;

        for(size_t j = 0; j < d.dependencies.size(); ++j)
        {
            string dependeeBasename = PathBasename(d.dependencies[j]);
            Dylib &dependee = dylibs[dependeeBasename];
            if (!dependee.fullpath.empty())
            {
                string desiredPath = "@executable_path/" + PathRelativeTo(appPath + "/Contents/MacOS", dependee.fullpath);
                if (d.baseFilename != dependeeBasename) // Don't do deps to itself.
                if (d.dependencies[j] != desiredPath)
                {
                    cout << d.baseFilename << " depends on " << dependeeBasename << ", located in " << dependee.fullpath << endl;
                    cout << "Needs to depend on " << desiredPath << endl;
                    cout << (string("install_name_tool -change ") + d.dependencies[j] + " " + desiredPath + " " + d.fullpath).c_str() << endl;
                    system((string("install_name_tool -change ") + d.dependencies[j] + " " + desiredPath + " " + d.fullpath).c_str());
                }
            }
            else if (EndsWith(dependeeBasename, ".dylib"))
                cout << "ERROR! Cannot locate " << d.dependencies[j] << "!" << endl;
        }
    }
    
    cout << "Done." << endl;
    
    return 0;
}
